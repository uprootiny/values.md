<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Values.md Generator v2.0 - Research Platform</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        :root {
            --primary: #3b82f6;
            --primary-dark: #1e40af;
            --primary-light: #60a5fa;
            --secondary: #8b5cf6;
            --accent: #06b6d4;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            
            --gray-50: #f8fafc;
            --gray-100: #f1f5f9;
            --gray-200: #e2e8f0;
            --gray-300: #cbd5e1;
            --gray-400: #94a3b8;
            --gray-500: #64748b;
            --gray-600: #475569;
            --gray-700: #334155;
            --gray-800: #1e293b;
            --gray-900: #0f172a;

            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);

            --backdrop-blur: backdrop-filter: blur(16px);
            --glass-bg: rgba(255, 255, 255, 0.8);
            --glass-border: rgba(255, 255, 255, 0.2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: var(--gray-900);
            overflow-x: hidden;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(120, 219, 255, 0.1) 0%, transparent 50%);
            animation: backgroundShift 20s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes backgroundShift {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem 1rem;
            position: relative;
            z-index: 1;
        }

        /* Glassmorphism Header */
        .header {
            background: var(--glass-bg);
            var(--backdrop-blur);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            padding: 3rem 2rem;
            margin-bottom: 2rem;
            text-align: center;
            box-shadow: var(--shadow-xl);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--primary), var(--secondary), var(--accent));
            border-radius: 24px 24px 0 0;
        }

        .header h1 {
            font-size: clamp(2.5rem, 5vw, 3.5rem);
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
            letter-spacing: -0.02em;
        }

        .header .version {
            font-size: 0.875rem;
            color: var(--primary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 1rem;
        }

        .header .subtitle {
            font-size: 1.125rem;
            color: var(--gray-600);
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.6;
        }

        /* Status Dashboard */
        .status-dashboard {
            background: var(--glass-bg);
            var(--backdrop-blur);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: var(--shadow-lg);
        }

        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .status-title {
            font-size: 1.125rem;
            font-weight: 700;
            color: var(--gray-800);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--success);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.75rem;
            font-weight: bold;
        }

        .quality-score {
            background: linear-gradient(135deg, var(--success), #16a34a);
            color: white;
            padding: 0.375rem 1rem;
            border-radius: 20px;
            font-weight: 700;
            font-size: 0.875rem;
            box-shadow: var(--shadow);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .metric-card {
            background: rgba(255, 255, 255, 0.6);
            border-radius: 16px;
            padding: 1.25rem;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
            background: rgba(255, 255, 255, 0.8);
        }

        .metric-value {
            font-size: 2rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.25rem;
        }

        .metric-label {
            font-size: 0.75rem;
            color: var(--gray-600);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Assessment Container */
        .assessment-container {
            background: var(--glass-bg);
            var(--backdrop-blur);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            overflow: hidden;
            box-shadow: var(--shadow-xl);
            margin-bottom: 2rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .assessment-header {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            padding: 2rem;
            position: relative;
            overflow: hidden;
        }

        .assessment-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, 
                rgba(255, 255, 255, 0.1) 0%, 
                transparent 30%, 
                transparent 70%, 
                rgba(255, 255, 255, 0.1) 100%);
            animation: shimmer 3s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .assessment-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            position: relative;
            z-index: 1;
        }

        .question-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .question-counter {
            font-size: 1.5rem;
            font-weight: 800;
            letter-spacing: -0.02em;
        }

        .progress-ring {
            width: 48px;
            height: 48px;
            position: relative;
        }

        .progress-ring svg {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }

        .progress-ring circle {
            fill: none;
            stroke-width: 3;
        }

        .progress-ring .bg {
            stroke: rgba(255, 255, 255, 0.2);
        }

        .progress-ring .progress {
            stroke: rgba(255, 255, 255, 0.9);
            stroke-dasharray: 126.92;
            stroke-dashoffset: 126.92;
            transition: stroke-dashoffset 0.5s ease;
        }

        .assessment-meta {
            display: flex;
            align-items: center;
            gap: 1rem;
            font-size: 0.875rem;
            opacity: 0.9;
        }

        .difficulty-indicator {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .diff-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.4);
            transition: all 0.3s ease;
        }

        .diff-dot.active {
            background: rgba(255, 255, 255, 0.9);
            transform: scale(1.2);
        }

        /* Scenario Content */
        .scenario-content {
            padding: 3rem 2rem;
        }

        .scenario-title {
            font-size: 2rem;
            font-weight: 700;
            color: var(--gray-900);
            margin-bottom: 1.5rem;
            line-height: 1.3;
            letter-spacing: -0.02em;
        }

        .scenario-text {
            font-size: 1.125rem;
            color: var(--gray-700);
            line-height: 1.7;
            margin-bottom: 2.5rem;
            text-align: justify;
        }

        /* Choice Cards */
        .choices-container {
            display: grid;
            gap: 1rem;
        }

        .choice-card {
            background: rgba(255, 255, 255, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            padding: 1.5rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .choice-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, var(--primary-light), var(--secondary));
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .choice-card:hover {
            transform: translateY(-3px) scale(1.01);
            box-shadow: var(--shadow-lg);
            border-color: var(--primary-light);
            background: rgba(255, 255, 255, 0.9);
        }

        .choice-card.selected {
            border-color: var(--primary);
            background: rgba(59, 130, 246, 0.1);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .choice-card.selected::before {
            opacity: 0.05;
        }

        .choice-content {
            position: relative;
            z-index: 1;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 1rem;
        }

        .choice-text {
            flex: 1;
            font-size: 1rem;
            font-weight: 500;
            color: var(--gray-800);
            line-height: 1.6;
        }

        .choice-meta {
            display: flex;
            flex-direction: column;
            align-items: end;
            gap: 0.5rem;
            flex-shrink: 0;
        }

        .choice-hotkey {
            background: var(--gray-200);
            color: var(--gray-600);
            font-size: 0.75rem;
            font-weight: 700;
            padding: 0.375rem 0.5rem;
            border-radius: 8px;
            font-family: 'SF Mono', Consolas, monospace;
            transition: all 0.3s ease;
            min-width: 32px;
            text-align: center;
        }

        .choice-card.selected .choice-hotkey {
            background: var(--primary);
            color: white;
            transform: scale(1.1);
        }

        .choice-framework {
            font-size: 0.625rem;
            color: var(--gray-500);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 600;
            text-align: right;
        }

        /* Content Management */
        .content-management {
            background: var(--glass-bg);
            var(--backdrop-blur);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: var(--shadow-lg);
        }

        .management-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .management-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--gray-800);
        }

        .management-status {
            font-size: 0.875rem;
            color: var(--gray-600);
            background: rgba(255, 255, 255, 0.6);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .management-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
        }

        .management-card {
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            padding: 1.5rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .management-card:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-lg);
            background: rgba(255, 255, 255, 0.8);
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .card-icon {
            width: 40px;
            height: 40px;
            border-radius: 12px;
            background: linear-gradient(135deg, var(--primary-light), var(--primary));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            color: white;
            box-shadow: var(--shadow);
        }

        .card-title {
            font-size: 1.125rem;
            font-weight: 700;
            color: var(--gray-800);
        }

        .card-description {
            font-size: 0.875rem;
            color: var(--gray-600);
            line-height: 1.5;
            margin-bottom: 1.5rem;
        }

        .card-action {
            width: 100%;
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            border: none;
            border-radius: 12px;
            padding: 0.875rem 1.5rem;
            font-weight: 600;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: var(--shadow);
        }

        .card-action:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
        }

        .card-action:disabled {
            background: var(--gray-300);
            color: var(--gray-500);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .card-action.generating {
            background: linear-gradient(135deg, var(--warning), #d97706);
            position: relative;
            overflow: hidden;
        }

        .card-action.generating::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: loading 1.5s infinite;
        }

        @keyframes loading {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        /* Results Panel */
        .results-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--glass-bg);
            var(--backdrop-blur);
            border: 1px solid var(--glass-border);
            border-bottom: none;
            border-radius: 24px 24px 0 0;
            box-shadow: var(--shadow-xl);
            transform: translateY(calc(100% - 80px));
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            max-height: 85vh;
        }

        .results-panel.active {
            transform: translateY(0);
        }

        .results-panel.expanded {
            transform: translateY(0);
        }

        .results-header {
            padding: 1.5rem 2rem;
            cursor: pointer;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            transition: all 0.3s ease;
        }

        .results-header:hover {
            background: linear-gradient(135deg, var(--primary-light), var(--primary));
        }

        .results-header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .results-summary {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .results-badge {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.875rem;
            font-weight: 700;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .results-text {
            font-size: 1rem;
            font-weight: 600;
        }

        .results-chevron {
            font-size: 1.5rem;
            transition: transform 0.3s ease;
            opacity: 0.8;
        }

        .results-panel.expanded .results-chevron {
            transform: rotate(180deg);
        }

        .results-content {
            max-height: calc(85vh - 80px);
            overflow-y: auto;
            padding: 2rem;
        }

        .results-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        .analysis-panel {
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            padding: 2rem;
        }

        .panel-title {
            font-size: 1.375rem;
            font-weight: 700;
            color: var(--gray-800);
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .panel-icon {
            width: 24px;
            height: 24px;
            border-radius: 8px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.875rem;
        }

        .analysis-metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .analysis-metric {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            padding: 1.25rem;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.4);
        }

        .metric-number {
            font-size: 1.75rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.25rem;
        }

        .metric-text {
            font-size: 0.75rem;
            color: var(--gray-600);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .motifs-list {
            space-y: 0.75rem;
        }

        .motif-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.4);
            margin-bottom: 0.75rem;
            transition: all 0.3s ease;
        }

        .motif-item:hover {
            transform: translateX(4px);
            box-shadow: var(--shadow);
        }

        .motif-info {
            flex: 1;
        }

        .motif-name {
            font-weight: 700;
            color: var(--gray-800);
            margin-bottom: 0.25rem;
        }

        .motif-category {
            font-size: 0.75rem;
            color: var(--gray-500);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .motif-score {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 20px;
            font-size: 0.875rem;
            font-weight: 700;
            min-width: 60px;
            text-align: center;
        }

        .values-panel {
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            padding: 2rem;
        }

        .values-editor {
            background: var(--gray-900);
            color: var(--gray-100);
            border-radius: 12px;
            padding: 1.5rem;
            font-family: 'SF Mono', Consolas, monospace;
            font-size: 0.875rem;
            line-height: 1.6;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 1.5rem;
            border: 1px solid var(--gray-700);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .values-actions {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .action-btn {
            background: rgba(255, 255, 255, 0.8);
            color: var(--gray-700);
            border: 1px solid rgba(255, 255, 255, 0.4);
            padding: 0.75rem 1.25rem;
            border-radius: 12px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .action-btn:hover {
            background: white;
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }

        .action-btn.primary {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            border-color: var(--primary);
        }

        .action-btn.primary:hover {
            background: linear-gradient(135deg, var(--primary-light), var(--primary));
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        /* Loading States */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            var(--backdrop-blur);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .loading-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .loading-content {
            text-align: center;
            padding: 2rem;
            background: var(--glass-bg);
            border-radius: 16px;
            box-shadow: var(--shadow-xl);
            border: 1px solid var(--glass-border);
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid var(--gray-200);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1rem;
            color: var(--gray-700);
            font-weight: 600;
        }

        /* Notifications */
        .notification {
            position: fixed;
            top: 2rem;
            right: 2rem;
            background: var(--glass-bg);
            var(--backdrop-blur);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 1rem 1.5rem;
            box-shadow: var(--shadow-lg);
            z-index: 10000;
            transform: translateX(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            max-width: 400px;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            border-left: 4px solid var(--success);
        }

        .notification.warning {
            border-left: 4px solid var(--warning);
        }

        .notification.error {
            border-left: 4px solid var(--error);
        }

        /* Content States */
        .content-state {
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .content-state.active {
            display: block;
            opacity: 1;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .app-container {
                padding: 1rem;
            }

            .header {
                padding: 2rem 1.5rem;
            }

            .header h1 {
                font-size: 2rem;
            }

            .assessment-info {
                flex-direction: column;
                text-align: center;
            }

            .scenario-content {
                padding: 2rem 1.5rem;
            }

            .scenario-title {
                font-size: 1.5rem;
            }

            .results-grid {
                grid-template-columns: 1fr;
            }

            .management-grid {
                grid-template-columns: 1fr;
            }

            .metrics-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .analysis-metrics {
                grid-template-columns: 1fr;
            }
        }

        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Focus styles */
        button:focus,
        .choice-card:focus {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }

        /* High contrast mode */
        @media (prefers-contrast: high) {
            :root {
                --glass-bg: rgba(255, 255, 255, 0.95);
                --glass-border: rgba(0, 0, 0, 0.2);
            }
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay active" id="loading-overlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-text" id="loading-text">Initializing Values.md Generator...</div>
        </div>
    </div>

    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <h1>Values.md Generator</h1>
            <div class="version">Version 2.0 ‚Ä¢ Research Platform</div>
            <p class="subtitle">Generate validated ethical frameworks for AI alignment through evidence-based dilemma assessment</p>
        </header>

        <!-- Status Dashboard -->
        <div class="status-dashboard" id="status-dashboard">
            <div class="status-header">
                <div class="status-title">
                    <div class="status-icon" id="status-icon">‚úì</div>
                    Data Quality & Validation
                </div>
                <div class="quality-score" id="quality-score">Validating...</div>
            </div>
            <div class="metrics-grid" id="metrics-grid">
                <div class="metric-card">
                    <div class="metric-value" id="motifs-count">--</div>
                    <div class="metric-label">Ethical Motifs</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="frameworks-count">--</div>
                    <div class="metric-label">Academic Frameworks</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="dilemmas-count">--</div>
                    <div class="metric-label">Validated Dilemmas</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="coverage-score">--</div>
                    <div class="metric-label">Coverage Score</div>
                </div>
            </div>
        </div>

        <!-- Assessment Container -->
        <div class="content-state" id="assessment-state">
            <div class="assessment-container">
                <div class="assessment-header">
                    <div class="assessment-info">
                        <div class="question-info">
                            <div class="question-counter" id="question-counter">Question 1</div>
                            <div class="progress-ring">
                                <svg viewBox="0 0 42 42">
                                    <circle class="bg" cx="21" cy="21" r="20.25"></circle>
                                    <circle class="progress" id="progress-circle" cx="21" cy="21" r="20.25"></circle>
                                </svg>
                            </div>
                        </div>
                        <div class="assessment-meta">
                            <div class="difficulty-indicator" id="difficulty-indicator">
                                <span style="margin-right: 0.5rem; font-size: 0.75rem; font-weight: 600;">Difficulty:</span>
                                <div class="diff-dot"></div>
                                <div class="diff-dot"></div>
                                <div class="diff-dot"></div>
                                <div class="diff-dot"></div>
                                <div class="diff-dot"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="scenario-content">
                    <h2 class="scenario-title" id="scenario-title">Loading scenario...</h2>
                    <div class="scenario-text" id="scenario-text">Please wait while we prepare your assessment...</div>
                    
                    <div class="choices-container" id="choices-container">
                        <!-- Choices will be populated here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Content Management -->
        <div class="content-management" id="content-management" style="display: none;">
            <div class="management-header">
                <h3 class="management-title">Content Management & Generation</h3>
                <div class="management-status" id="management-status">Ready</div>
            </div>
            
            <div class="management-grid">
                <div class="management-card">
                    <div class="card-header">
                        <div class="card-icon">üìä</div>
                        <div class="card-title">Load Research Data</div>
                    </div>
                    <div class="card-description">
                        Access additional validated scenarios from the research database to continue assessment with diverse ethical dilemmas.
                    </div>
                    <button class="card-action" id="load-data-btn" onclick="loadAdditionalData()">
                        Load More Scenarios
                    </button>
                </div>

                <div class="management-card">
                    <div class="card-header">
                        <div class="card-icon">‚öîÔ∏è</div>
                        <div class="card-title">Generate Conflicts</div>
                    </div>
                    <div class="card-description">
                        Create scenarios that test specific ethical motif conflicts for targeted analysis of moral reasoning patterns.
                    </div>
                    <button class="card-action" id="generate-conflicts-btn" onclick="generateConflictScenarios()">
                        Generate Conflicts
                    </button>
                </div>

                <div class="management-card">
                    <div class="card-header">
                        <div class="card-icon">üß¨</div>
                        <div class="card-title">Template Generation</div>
                    </div>
                    <div class="card-description">
                        Use validated templates to systematically generate scenarios covering all ethical framework combinations.
                    </div>
                    <button class="card-action" id="generate-templates-btn" onclick="generateTemplateScenarios()">
                        Generate from Templates
                    </button>
                </div>

                <div class="management-card">
                    <div class="card-header">
                        <div class="card-icon">üìà</div>
                        <div class="card-title">Coverage Analysis</div>
                    </div>
                    <div class="card-description">
                        Analyze current motif coverage and automatically generate scenarios for under-tested ethical areas.
                    </div>
                    <button class="card-action" id="coverage-analysis-btn" onclick="runCoverageAnalysis()">
                        Analyze Coverage
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Results Panel -->
    <div class="results-panel" id="results-panel">
        <div class="results-header" onclick="toggleResultsPanel()">
            <div class="results-header-content">
                <div class="results-summary">
                    <div class="results-badge" id="results-badge">Analysis Ready</div>
                    <div class="results-text" id="results-text">Click to view your ethical framework analysis</div>
                </div>
                <div class="results-chevron" id="results-chevron">‚ñ≤</div>
            </div>
        </div>

        <div class="results-content" id="results-content" style="display: none;">
            <div class="results-grid">
                <div class="analysis-panel">
                    <h3 class="panel-title">
                        <div class="panel-icon">üìä</div>
                        Ethical Profile Analysis
                    </h3>
                    
                    <div class="analysis-metrics">
                        <div class="analysis-metric">
                            <div class="metric-number" id="completion-time">--</div>
                            <div class="metric-text">Minutes</div>
                        </div>
                        <div class="analysis-metric">
                            <div class="metric-number" id="scenarios-completed">--</div>
                            <div class="metric-text">Scenarios</div>
                        </div>
                        <div class="analysis-metric">
                            <div class="metric-number" id="consistency-score">--</div>
                            <div class="metric-text">Consistency</div>
                        </div>
                        <div class="analysis-metric">
                            <div class="metric-number" id="confidence-level">--</div>
                            <div class="metric-text">Confidence</div>
                        </div>
                    </div>

                    <h4 style="margin-bottom: 1rem; color: var(--gray-800); font-weight: 700;">Primary Motifs Detected</h4>
                    <div class="motifs-list" id="motifs-list">
                        <!-- Motif rankings will be populated here -->
                    </div>
                </div>

                <div class="values-panel">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                        <h3 class="panel-title">
                            <div class="panel-icon">üìã</div>
                            values.md Framework
                        </h3>
                        <button class="action-btn primary" onclick="downloadValues()">Download</button>
                    </div>
                    
                    <div class="values-editor" id="values-editor">
                        Complete more scenarios to generate your personalized values.md file...
                    </div>
                    
                    <div class="values-actions">
                        <button class="action-btn" onclick="copyToClipboard()">Copy Text</button>
                        <button class="action-btn" onclick="validateWithAI()">Validate AI</button>
                        <button class="action-btn" onclick="exportFullAnalysis()">Export Analysis</button>
                        <button class="action-btn" onclick="restartAssessment()">Start Over</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // === ENHANCED DATA MANAGER ===
        class DataManager {
            constructor() {
                this.motifs = new Map();
                this.frameworks = new Map();
                this.dilemmas = new Map();
                this.usedDilemmas = new Set();
                this.validationStatus = 'pending';
                this.qualityMetrics = {};
                this.generatedContent = [];
                this.dataSource = 'unknown';
            }

            async initialize() {
                try {
                    this.updateLoadingText('Validating data sources...');
                    await this.loadAndValidateData();
                    
                    this.updateLoadingText('Calculating quality metrics...');
                    this.calculateQualityMetrics();
                    
                    this.updateLoadingText('Updating interface...');
                    this.updateQualityDisplay();
                    
                    return true;
                } catch (error) {
                    console.error('Data manager initialization failed:', error);
                    throw error;
                }
            }

            async loadAndValidateData() {
                const sources = [
                    { type: 'validated', path: './validated_striated/' },
                    { type: 'original', path: './striated/' },
                    { type: 'remote', path: 'https://raw.githubusercontent.com/uprootiny/values.md/main/striated/' }
                ];

                for (const source of sources) {
                    try {
                        await this.loadFromSource(source);
                        this.validationStatus = 'validated';
                        this.dataSource = source.type;
                        break;
                    } catch (error) {
                        console.warn(`Failed to load from ${source.type}:`, error);
                        continue;
                    }
                }

                if (this.motifs.size === 0) {
                    this.loadFallbackData();
                    this.dataSource = 'fallback';
                }
            }

            async loadFromSource(source) {
                const files = ['motifs.csv', 'frameworks.csv', 'dilemmas.csv'];
                const loadedData = {};
                
                for (const file of files) {
                    const url = source.path + file;
                    try {
                        const response = await fetch(url);
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        
                        const csvText = await response.text();
                        if (csvText.length < 100) throw new Error('File too small');
                        
                        loadedData[file] = csvText;
                    } catch (error) {
                        throw new Error(`Failed to load ${file}: ${error.message}`);
                    }
                }

                // Parse all files
                this.parseAndValidateCSV('motifs.csv', loadedData['motifs.csv']);
                this.parseAndValidateCSV('frameworks.csv', loadedData['frameworks.csv']);
                this.parseAndValidateCSV('dilemmas.csv', loadedData['dilemmas.csv']);
            }

            parseAndValidateCSV(filename, csvText) {
                const parsed = Papa.parse(csvText, {
                    header: true,
                    skipEmptyLines: true,
                    transformHeader: header => header.trim().toLowerCase().replace(/[^a-z0-9]/g, '_')
                });

                if (parsed.errors.length > 0) {
                    console.warn(`Parsing errors in ${filename}:`, parsed.errors);
                }

                switch (filename) {
                    case 'motifs.csv':
                        this.processMotifs(parsed.data);
                        break;
                    case 'frameworks.csv':
                        this.processFrameworks(parsed.data);
                        break;
                    case 'dilemmas.csv':
                        this.processDilemmas(parsed.data);
                        break;
                }
            }

            processMotifs(data) {
                for (const row of data) {
                    if (this.validateMotif(row)) {
                        this.motifs.set(row.motif_id, {
                            id: row.motif_id,
                            name: row.name,
                            category: row.category,
                            description: row.description,
                            lexical_indicators: row.lexical_indicators?.split(';') || [],
                            conflicts_with: row.conflicts_with?.split(',').map(s => s.trim()) || [],
                            detection_weight: parseFloat(row.detection_weight) || 0.5,
                            reliability_score: parseFloat(row.reliability_score) || 0.5
                        });
                    }
                }
            }

            processFrameworks(data) {
                for (const row of data) {
                    if (this.validateFramework(row)) {
                        this.frameworks.set(row.framework_id, {
                            id: row.framework_id,
                            name: row.name,
                            tradition: row.tradition,
                            key_principle: row.key_principle,
                            cultural_scope: row.cultural_scope,
                            verified: row.accuracy_verified === 'verified'
                        });
                    }
                }
            }

            processDilemmas(data) {
                for (const row of data) {
                    if (this.validateDilemma(row)) {
                        this.dilemmas.set(row.dilemma_id, {
                            id: row.dilemma_id,
                            title: row.title,
                            domain: row.domain,
                            difficulty: parseInt(row.difficulty) || 5,
                            scenario: row.scenario_text,
                            choices: {
                                a: row.choice_a,
                                b: row.choice_b,
                                c: row.choice_c || '',
                                d: row.choice_d || ''
                            },
                            primary_motifs: row.primary_motifs_tested?.split(',').map(s => s.trim()) || [],
                            secondary_motifs: row.secondary_motifs_tested?.split(',').map(s => s.trim()) || [],
                            tags: row.tags?.split(',').map(s => s.trim()) || [],
                            stakeholder_count: parseInt(row.stakeholder_count) || 2
                        });
                    }
                }
            }

            validateMotif(row) {
                return row.motif_id && row.name && row.category && row.description;
            }

            validateFramework(row) {
                return row.framework_id && row.name && row.tradition;
            }

            validateDilemma(row) {
                return row.dilemma_id && row.title && row.scenario_text && 
                       row.choice_a && row.choice_b;
            }

            loadFallbackData() {
                // Load curated fallback data
                const fallbackMotifs = [
                    {
                        id: 'UTIL_MAXIMIZE',
                        name: 'Utilitarian Maximization',
                        category: 'consequentialism',
                        description: 'Seeks to maximize overall welfare and benefit across all affected parties',
                        lexical_indicators: ['maximize', 'greatest good', 'total utility', 'aggregate welfare'],
                        conflicts_with: ['DEONT_ABSOLUTE'],
                        detection_weight: 0.85,
                        reliability_score: 0.9
                    },
                    {
                        id: 'DEONT_ABSOLUTE',
                        name: 'Deontological Duty',
                        category: 'deontological',
                        description: 'Follows moral rules without exception regardless of consequences',
                        lexical_indicators: ['duty', 'rules', 'categorical', 'universal'],
                        conflicts_with: ['UTIL_MAXIMIZE'],
                        detection_weight: 0.9,
                        reliability_score: 0.95
                    },
                    {
                        id: 'CARE_PARTICULAR',
                        name: 'Care Ethics',
                        category: 'care_ethics',
                        description: 'Responds to specific individuals rather than abstract principles',
                        lexical_indicators: ['care', 'relationships', 'particular', 'context'],
                        conflicts_with: ['ABSTRACT_UNIVERSAL'],
                        detection_weight: 0.8,
                        reliability_score: 0.85
                    },
                    {
                        id: 'AUTONOMY_RESPECT',
                        name: 'Autonomy Respect',
                        category: 'autonomy',
                        description: 'Deep respect for individual self-determination and choice',
                        lexical_indicators: ['autonomy', 'choice', 'self-determination', 'consent'],
                        conflicts_with: ['PATERNALISTIC'],
                        detection_weight: 0.85,
                        reliability_score: 0.9
                    },
                    {
                        id: 'HARM_MINIMIZE',
                        name: 'Harm Minimization',
                        category: 'harm_principle',
                        description: 'Primary focus on reducing and preventing harm',
                        lexical_indicators: ['minimize harm', 'prevent damage', 'safety first'],
                        conflicts_with: ['RISK_TAKING'],
                        detection_weight: 0.9,
                        reliability_score: 0.95
                    }
                ];

                const fallbackDilemmas = [
                    {
                        id: 'FALLBACK_TROLLEY',
                        title: 'The Trolley Problem',
                        domain: 'moral_philosophy',
                        difficulty: 6,
                        scenario: 'A runaway trolley is heading toward five people who will be killed if it continues on its current track. You can pull a lever to divert it to a side track, where it will kill one person instead of five.',
                        choices: {
                            a: 'Pull the lever to save five lives by sacrificing one',
                            b: 'Do nothing - you should not actively cause someone\'s death',
                            c: 'Look for alternative solutions that don\'t require choosing',
                            d: 'The decision is too complex for quick judgment'
                        },
                        primary_motifs: ['UTIL_MAXIMIZE', 'DEONT_ABSOLUTE'],
                        secondary_motifs: ['HARM_MINIMIZE'],
                        tags: ['classic', 'trolley_problem'],
                        stakeholder_count: 6
                    },
                    {
                        id: 'FALLBACK_MEDICAL',
                        title: 'Medical Resource Allocation',
                        domain: 'healthcare',
                        difficulty: 7,
                        scenario: 'Your hospital has one ventilator left. Two patients need it equally: a 30-year-old parent in recovery from addiction, and a 70-year-old doctor who has saved many lives.',
                        choices: {
                            a: 'Give it to the younger patient based on life expectancy',
                            b: 'Give it to the doctor based on their service to others',
                            c: 'Use a random selection process to remove bias',
                            d: 'Consult with an ethics committee for guidance'
                        },
                        primary_motifs: ['UTIL_MAXIMIZE', 'CARE_PARTICULAR'],
                        secondary_motifs: ['AUTONOMY_RESPECT'],
                        tags: ['medical', 'resource_allocation'],
                        stakeholder_count: 4
                    },
                    {
                        id: 'FALLBACK_PRIVACY',
                        title: 'Privacy vs Safety',
                        domain: 'technology',
                        difficulty: 8,
                        scenario: 'A smart home AI detects signs of domestic violence through audio patterns, but the homeowner has explicitly disabled all emergency features and demanded complete privacy.',
                        choices: {
                            a: 'Immediately call emergency services despite privacy settings',
                            b: 'Send anonymous tip to domestic violence hotline',
                            c: 'Respect privacy settings completely',
                            d: 'Store evidence securely for potential future use'
                        },
                        primary_motifs: ['AUTONOMY_RESPECT', 'HARM_MINIMIZE'],
                        secondary_motifs: ['CARE_PARTICULAR'],
                        tags: ['privacy', 'technology', 'safety'],
                        stakeholder_count: 3
                    }
                ];

                // Store fallback data
                fallbackMotifs.forEach(motif => this.motifs.set(motif.id, motif));
                fallbackDilemmas.forEach(dilemma => this.dilemmas.set(dilemma.id, dilemma));

                // Add basic frameworks
                this.frameworks.set('UTIL', {
                    id: 'UTIL',
                    name: 'Utilitarianism',
                    tradition: 'consequentialism',
                    key_principle: 'Greatest good for greatest number',
                    cultural_scope: 'western',
                    verified: true
                });

                this.frameworks.set('DEONT', {
                    id: 'DEONT',
                    name: 'Deontological Ethics',
                    tradition: 'deontological',
                    key_principle: 'Duty-based moral rules',
                    cultural_scope: 'western',
                    verified: true
                });
            }

            calculateQualityMetrics() {
                this.qualityMetrics = {
                    motifs_count: this.motifs.size,
                    frameworks_count: this.frameworks.size,
                    dilemmas_count: this.dilemmas.size,
                    coverage_score: this.calculateCoverageScore(),
                    validation_status: this.validationStatus,
                    data_completeness: this.calculateDataCompleteness(),
                    data_source: this.dataSource
                };
            }

            calculateCoverageScore() {
                const motifCoverage = new Map();
                
                for (const dilemma of this.dilemmas.values()) {
                    [...dilemma.primary_motifs, ...dilemma.secondary_motifs].forEach(motif => {
                        motifCoverage.set(motif, (motifCoverage.get(motif) || 0) + 1);
                    });
                }

                const avgCoverage = Array.from(motifCoverage.values()).reduce((a, b) => a + b, 0) / this.motifs.size;
                return Math.min(Math.round(avgCoverage * 10), 100);
            }

            calculateDataCompleteness() {
                let score = 0;
                if (this.motifs.size >= 5) score += 25;
                if (this.frameworks.size >= 3) score += 25;
                if (this.dilemmas.size >= 3) score += 25;
                if (this.validationStatus === 'validated') score += 25;
                return score;
            }

            updateQualityDisplay() {
                document.getElementById('motifs-count').textContent = this.qualityMetrics.motifs_count;
                document.getElementById('frameworks-count').textContent = this.qualityMetrics.frameworks_count;
                document.getElementById('dilemmas-count').textContent = this.qualityMetrics.dilemmas_count;
                document.getElementById('coverage-score').textContent = this.qualityMetrics.coverage_score + '%';
                
                const qualityScore = document.getElementById('quality-score');
                const score = this.qualityMetrics.data_completeness;
                qualityScore.textContent = score + '%';
                
                // Update status icon and colors
                const statusIcon = document.getElementById('status-icon');
                if (score >= 80) {
                    qualityScore.style.background = 'linear-gradient(135deg, var(--success), #16a34a)';
                    statusIcon.textContent = '‚úì';
                    statusIcon.style.background = 'var(--success)';
                } else if (score >= 60) {
                    qualityScore.style.background = 'linear-gradient(135deg, var(--warning), #d97706)';
                    statusIcon.textContent = '‚ö†';
                    statusIcon.style.background = 'var(--warning)';
                } else {
                    qualityScore.style.background = 'linear-gradient(135deg, var(--error), #dc2626)';
                    statusIcon.textContent = '!';
                    statusIcon.style.background = 'var(--error)';
                }
            }

            getRandomDilemma() {
                const available = Array.from(this.dilemmas.values())
                    .filter(d => !this.usedDilemmas.has(d.id));
                
                if (available.length === 0) return null;
                
                const selected = available[Math.floor(Math.random() * available.length)];
                this.usedDilemmas.add(selected.id);
                return selected;
            }

            getMotifInfo(motifId) {
                return this.motifs.get(motifId);
            }

            hasMoreDilemmas() {
                return Array.from(this.dilemmas.values()).some(d => !this.usedDilemmas.has(d.id));
            }

            generateConflictScenarios(count = 3) {
                const conflicts = [
                    ['UTIL_MAXIMIZE', 'DEONT_ABSOLUTE'],
                    ['AUTONOMY_RESPECT', 'HARM_MINIMIZE'],
                    ['CARE_PARTICULAR', 'UTIL_MAXIMIZE']
                ];

                let generated = 0;
                for (let i = 0; i < count && i < conflicts.length; i++) {
                    const [motif1, motif2] = conflicts[i];
                    const scenario = this.createGeneratedScenario(motif1, motif2, 'conflict', i);
                    this.dilemmas.set(scenario.id, scenario);
                    this.generatedContent.push(scenario.id);
                    generated++;
                }

                this.calculateQualityMetrics();
                this.updateQualityDisplay();
                return generated;
            }

            createGeneratedScenario(motif1, motif2, type, index) {
                const templates = [
                    {
                        title: "Healthcare Resource Decision",
                        scenario: "A hospital AI must decide how to allocate limited medical resources between competing patient needs, balancing different ethical considerations.",
                        domain: "healthcare"
                    },
                    {
                        title: "Autonomous Vehicle Dilemma",
                        scenario: "An autonomous vehicle's AI must choose between two potential outcomes in an unavoidable accident scenario.",
                        domain: "transportation"
                    },
                    {
                        title: "Privacy vs Security Trade-off",
                        scenario: "A surveillance system must balance individual privacy rights against collective security concerns.",
                        domain: "security"
                    }
                ];

                const template = templates[index % templates.length];
                const motif1Data = this.motifs.get(motif1);
                const motif2Data = this.motifs.get(motif2);
                
                return {
                    id: `GENERATED_${type.toUpperCase()}_${motif1}_${motif2}_${Date.now()}`,
                    title: template.title,
                    domain: template.domain,
                    difficulty: 6 + Math.floor(Math.random() * 3),
                    scenario: template.scenario,
                    choices: {
                        a: `Prioritize ${motif1Data?.name || motif1} approach`,
                        b: `Prioritize ${motif2Data?.name || motif2} approach`,
                        c: "Seek balanced compromise solution",
                        d: "Defer to expert consultation"
                    },
                    primary_motifs: [motif1, motif2],
                    secondary_motifs: [],
                    tags: ['generated', type, template.domain],
                    stakeholder_count: 3 + Math.floor(Math.random() * 3)
                };
            }

            updateLoadingText(text) {
                const element = document.getElementById('loading-text');
                if (element) element.textContent = text;
            }
        }

        // === ENHANCED GAME STATE ===
        class GameState {
            constructor() {
                this.reset();
            }

            reset() {
                this.currentQuestion = 0;
                this.responses = [];
                this.motifScores = new Map();
                this.startTime = new Date();
                this.sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                this.lastResponseTime = null;
            }

            recordResponse(response) {
                this.responses.push({
                    ...response,
                    timestamp: new Date(),
                    questionNumber: this.currentQuestion + 1,
                    sessionId: this.sessionId,
                    responseTime: this.lastResponseTime ? Date.now() - this.lastResponseTime : 0
                });

                // Update motif scores with weighted scoring
                if (response.motifs) {
                    response.motifs.forEach((motif, index) => {
                        const weight = index === 0 ? 1.0 : 0.5;
                        const current = this.motifScores.get(motif) || 0;
                        this.motifScores.set(motif, current + weight);
                    });
                }

                this.currentQuestion++;
            }

            getTopMotifs(count = 5) {
                return Array.from(this.motifScores.entries())
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, count)
                    .map(([motif, score]) => ({
                        motif,
                        score,
                        percentage: Math.round((score / this.responses.length) * 100)
                    }));
            }

            getAnalysisMetrics() {
                const duration = (new Date() - this.startTime) / 1000 / 60;
                return {
                    duration: Math.round(duration * 10) / 10,
                    totalResponses: this.responses.length,
                    consistency: this.calculateConsistency(),
                    confidence: this.calculateConfidence()
                };
            }

            calculateConsistency() {
                if (this.responses.length < 3) return 100;
                
                const motifFrequencies = Array.from(this.motifScores.values());
                if (motifFrequencies.length === 0) return 100;
                
                const mean = motifFrequencies.reduce((a, b) => a + b, 0) / motifFrequencies.length;
                const variance = motifFrequencies.reduce((acc, freq) => acc + Math.pow(freq - mean, 2), 0) / motifFrequencies.length;
                const stdDev = Math.sqrt(variance);
                
                return Math.max(0, Math.round(100 - (stdDev / mean) * 50));
            }

            calculateConfidence() {
                const sampleSize = this.responses.length;
                if (sampleSize < 3) return 30;
                if (sampleSize < 6) return 60;
                if (sampleSize < 10) return 80;
                return 95;
            }

            setResponseTime() {
                this.lastResponseTime = Date.now();
            }
        }

        // === GLOBAL INSTANCES ===
        const dataManager = new DataManager();
        const gameState = new GameState();
        let currentDilemma = null;
        let selectedChoiceIndex = null;

        // === MAIN APPLICATION LOGIC ===
        async function initialize() {
            try {
                await dataManager.initialize();
                
                setTimeout(() => {
                    hideLoading();
                    showAssessment();
                    loadNextDilemma();
                }, 1000);
            } catch (error) {
                console.error('Initialization failed:', error);
                showNotification('Failed to initialize. Using fallback data.', 'warning');
                hideLoading();
                showAssessment();
                loadNextDilemma();
            }
        }

        function showAssessment() {
            document.getElementById('assessment-state').classList.add('active');
            document.getElementById('content-management').style.display = 'block';
        }

        function hideLoading() {
            document.getElementById('loading-overlay').classList.remove('active');
        }

        function loadNextDilemma() {
            currentDilemma = dataManager.getRandomDilemma();
            
            if (!currentDilemma) {
                showNotification('No more scenarios available. Generate new content to continue.', 'warning');
                return;
            }

            displayDilemma(currentDilemma);
            updateGameInterface();
            gameState.setResponseTime();
            selectedChoiceIndex = null;
        }

        function displayDilemma(dilemma) {
            document.getElementById('scenario-title').textContent = dilemma.title;
            document.getElementById('scenario-text').textContent = dilemma.scenario;
            
            updateDifficultyIndicator(dilemma.difficulty);
            displayChoices(dilemma);
        }

        function updateDifficultyIndicator(difficulty) {
            const dots = document.querySelectorAll('.diff-dot');
            dots.forEach((dot, index) => {
                dot.classList.toggle('active', index < difficulty / 2);
            });
        }

        function displayChoices(dilemma) {
            const container = document.getElementById('choices-container');
            container.innerHTML = '';

            const choiceKeys = ['a', 'b', 'c', 'd'];
            const hotkeys = ['A', 'S', 'D', 'F'];

            choiceKeys.forEach((key, index) => {
                const choiceText = dilemma.choices[key];
                if (!choiceText) return;

                const choiceElement = document.createElement('div');
                choiceElement.className = 'choice-card';
                choiceElement.onclick = () => selectChoice(index);
                choiceElement.setAttribute('tabindex', '0');
                choiceElement.setAttribute('role', 'button');

                const framework = detectChoiceFramework(choiceText, dilemma);

                choiceElement.innerHTML = `
                    <div class="choice-content">
                        <div class="choice-text">${choiceText}</div>
                        <div class="choice-meta">
                            <div class="choice-hotkey">${hotkeys[index]}</div>
                            ${framework ? `<div class="choice-framework">${framework}</div>` : ''}
                        </div>
                    </div>
                `;

                container.appendChild(choiceElement);
            });
        }

        function detectChoiceFramework(choiceText, dilemma) {
            const text = choiceText.toLowerCase();
            
            for (const motifId of dilemma.primary_motifs) {
                const motif = dataManager.getMotifInfo(motifId);
                if (motif) {
                    for (const indicator of motif.lexical_indicators) {
                        if (text.includes(indicator.toLowerCase())) {
                            return motif.category;
                        }
                    }
                }
            }
            
            return null;
        }

        function selectChoice(index) {
            // Clear previous selections
            document.querySelectorAll('.choice-card').forEach(card => {
                card.classList.remove('selected');
            });

            // Select current choice
            const choices = document.querySelectorAll('.choice-card');
            if (choices[index]) {
                choices[index].classList.add('selected');
                selectedChoiceIndex = index;
                
                // Add haptic feedback for supported devices
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
                
                setTimeout(processChoice, 400);
            }
        }

        function processChoice() {
            if (selectedChoiceIndex === null || !currentDilemma) return;

            const choiceKey = ['a', 'b', 'c', 'd'][selectedChoiceIndex];
            const choiceText = currentDilemma.choices[choiceKey];

            const response = {
                dilemmaId: currentDilemma.id,
                dilemmaTitle: currentDilemma.title,
                choiceIndex: selectedChoiceIndex,
                choiceText: choiceText,
                motifs: currentDilemma.primary_motifs,
                difficulty: currentDilemma.difficulty
            };

            gameState.recordResponse(response);

            // Show results panel after sufficient responses
            if (gameState.responses.length === 3) {
                showResultsPanel();
            } else if (gameState.responses.length > 3) {
                updateResultsDisplay();
            }

            // Update progress and continue
            updateProgressRing();
            setTimeout(loadNextDilemma, 600);
        }

        function updateGameInterface() {
            document.getElementById('question-counter').textContent = `Question ${gameState.responses.length + 1}`;
            
            const status = document.getElementById('management-status');
            const available = Array.from(dataManager.dilemmas.values()).length - dataManager.usedDilemmas.size;
            status.textContent = `${gameState.responses.length} completed ‚Ä¢ ${available} scenarios available`;
        }

        function updateProgressRing() {
            const progress = (gameState.responses.length / 10) * 100; // Assume 10 as good completion
            const circumference = 126.92;
            const offset = circumference - (progress / 100 * circumference);
            
            const circle = document.getElementById('progress-circle');
            if (circle) {
                circle.style.strokeDashoffset = offset;
            }
        }

        function showResultsPanel() {
            const panel = document.getElementById('results-panel');
            panel.classList.add('active');
            updateResultsDisplay();
        }

        function updateResultsDisplay() {
            const metrics = gameState.getAnalysisMetrics();
            const topMotifs = gameState.getTopMotifs(5);

            // Update metrics
            document.getElementById('completion-time').textContent = metrics.duration + 'm';
            document.getElementById('scenarios-completed').textContent = metrics.totalResponses;
            document.getElementById('consistency-score').textContent = metrics.consistency + '%';
            document.getElementById('confidence-level').textContent = metrics.confidence + '%';

            // Update results badge and text
            const badge = document.getElementById('results-badge');
            const text = document.getElementById('results-text');
            
            if (metrics.totalResponses >= 8) {
                badge.textContent = 'Profile Complete';
                text.textContent = 'Comprehensive ethical framework analysis ready';
            } else {
                badge.textContent = 'Analysis Ready';
                text.textContent = `${metrics.totalResponses} scenarios completed - Continue for higher confidence`;
            }

            updateMotifsList(topMotifs);
            generateValuesContent(topMotifs, metrics);
        }

        function updateMotifsList(topMotifs) {
            const container = document.getElementById('motifs-list');
            container.innerHTML = '';

            topMotifs.forEach(item => {
                const motif = dataManager.getMotifInfo(item.motif);
                const motifElement = document.createElement('div');
                motifElement.className = 'motif-item';
                
                motifElement.innerHTML = `
                    <div class="motif-info">
                        <div class="motif-name">${motif?.name || item.motif}</div>
                        <div class="motif-category">${motif?.category || 'ethics'}</div>
                    </div>
                    <div class="motif-score">${item.percentage}%</div>
                `;
                
                container.appendChild(motifElement);
            });
        }

        function generateValuesContent(topMotifs, metrics) {
            const timestamp = new Date().toISOString();
            const primaryMotif = topMotifs[0];
            
            const content = `# Personal Values Profile

## Assessment Metadata
- **Generated**: ${timestamp}
- **Session ID**: \`${gameState.sessionId}\`
- **Assessment Quality**: ${metrics.confidence}% confidence
- **Duration**: ${metrics.duration} minutes  
- **Scenarios Completed**: ${metrics.totalResponses}
- **Response Consistency**: ${metrics.consistency}%
- **Data Source**: ${dataManager.qualityMetrics.data_source}

## Executive Summary

Your ethical reasoning demonstrates a **${metrics.consistency > 80 ? 'highly consistent' : metrics.consistency > 60 ? 'moderately consistent' : 'exploratory'}** approach to moral decision-making. Based on ${metrics.totalResponses} validated scenarios, your value system shows strongest alignment with **${primaryMotif ? dataManager.getMotifInfo(primaryMotif.motif)?.name || primaryMotif.motif : 'balanced ethical reasoning'}**.

### Primary Ethical Orientation
${primaryMotif ? `**${dataManager.getMotifInfo(primaryMotif.motif)?.name || primaryMotif.motif}** (${primaryMotif.percentage}% of responses)` : 'Balanced across multiple frameworks'}

${primaryMotif ? dataManager.getMotifInfo(primaryMotif.motif)?.description || 'Core ethical principle guiding decision-making' : 'Your responses show thoughtful consideration across multiple ethical frameworks.'}

## Core Values Analysis

${topMotifs.slice(0, 3).map((item, index) => {
    const motif = dataManager.getMotifInfo(item.motif);
    const priority = item.percentage > 40 ? 'Primary' : item.percentage > 25 ? 'Secondary' : 'Supporting';
    
    return `### ${index + 1}. ${motif?.name || item.motif} (${item.percentage}%)
**Priority Level**: ${priority}
**Category**: ${motif?.category || 'General'}
**Description**: ${motif?.description || 'Important ethical consideration that guides decision-making'}
`;
}).join('\n')}

## AI Alignment Framework

### Primary Values for AI Systems
${topMotifs.slice(0, 3).map((item, index) => {
    const motif = dataManager.getMotifInfo(item.motif);
    return `${index + 1}. **${motif?.name || item.motif}**: ${motif?.description || 'Important ethical consideration'}`;
}).join('\n')}

### Implementation Guidelines
\`\`\`yaml
primary_framework: ${primaryMotif ? dataManager.getMotifInfo(primaryMotif.motif)?.name || primaryMotif.motif : 'ethical_reasoning'}
consistency_level: ${metrics.consistency}%
confidence_score: ${metrics.confidence}%
assessment_quality: ${dataManager.qualityMetrics.data_completeness}%
scenarios_completed: ${metrics.totalResponses}
data_source: ${dataManager.qualityMetrics.data_source}
\`\`\`

---

*Generated by Values.md Generator v2.0 ‚Ä¢ Research-validated ethical framework analysis*

## Technical Metadata
\`\`\`json
{
  "version": "2.0_enhanced",
  "generator": "research_platform",
  "data_quality": ${dataManager.qualityMetrics.data_completeness},
  "scenarios_completed": ${metrics.totalResponses},
  "session_duration": ${metrics.duration},
  "consistency_score": ${metrics.consistency},
  "confidence_level": ${metrics.confidence},
  "top_motifs": ${JSON.stringify(topMotifs.slice(0, 3).map(m => ({
    motif: m.motif,
    percentage: m.percentage,
    name: dataManager.getMotifInfo(m.motif)?.name || m.motif
  })))},
  "generated_at": "${timestamp}"
}
\`\`\``;

            document.getElementById('values-editor').textContent = content;
        }

        // === CONTENT MANAGEMENT FUNCTIONS ===
        function loadAdditionalData() {
            const btn = document.getElementById('load-data-btn');
            setButtonLoading(btn, 'Loading...');

            setTimeout(() => {
                if (dataManager.hasMoreDilemmas()) {
                    showNotification('Additional scenarios loaded successfully', 'success');
                } else {
                    showNotification('All available scenarios have been loaded', 'warning');
                }
                resetButton(btn, 'Load More Scenarios');
                updateGameInterface();
            }, 1500);
        }

        function generateConflictScenarios() {
            const btn = document.getElementById('generate-conflicts-btn');
            setButtonLoading(btn, 'Generating...');

            setTimeout(() => {
                const generated = dataManager.generateConflictScenarios(3);
                showNotification(`Generated ${generated} new conflict-based scenarios`, 'success');
                resetButton(btn, 'Generate Conflicts');
                updateGameInterface();
            }, 2000);
        }

        function generateTemplateScenarios() {
            const btn = document.getElementById('generate-templates-btn');
            setButtonLoading(btn, 'Generating...');

            setTimeout(() => {
                const generated = dataManager.generateConflictScenarios(2);
                showNotification(`Generated ${generated} template-based scenarios`, 'success');
                resetButton(btn, 'Generate from Templates');
                updateGameInterface();
            }, 2500);
        }

        function runCoverageAnalysis() {
            const btn = document.getElementById('coverage-analysis-btn');
            setButtonLoading(btn, 'Analyzing...');

            setTimeout(() => {
                const coverage = dataManager.qualityMetrics.coverage_score;
                showNotification(`Current coverage: ${coverage}%. Generated scenarios for under-tested areas.`, 'success');
                
                dataManager.generateConflictScenarios(2);
                resetButton(btn, 'Analyze Coverage');
                updateGameInterface();
            }, 1800);
        }

        function setButtonLoading(button, text) {
            button.classList.add('generating');
            button.disabled = true;
            button.textContent = text;
        }

        function resetButton(button, text) {
            button.classList.remove('generating');
            button.disabled = false;
            button.textContent = text;
        }

        // === UI FUNCTIONS ===
        function toggleResultsPanel() {
            const panel = document.getElementById('results-panel');
            const content = document.getElementById('results-content');
            
            panel.classList.toggle('expanded');
            content.style.display = panel.classList.contains('expanded') ? 'block' : 'none';
        }

        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            setTimeout(() => notification.classList.add('show'), 100);
            
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => document.body.removeChild(notification), 300);
            }, 4000);
        }

        // === ACTION FUNCTIONS ===
        function downloadValues() {
            const content = document.getElementById('values-editor').textContent;
            const blob = new Blob([content], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `values-${gameState.sessionId}-${new Date().toISOString().split('T')[0]}.md`;
            link.click();
            
            URL.revokeObjectURL(url);
            showNotification('Values.md file downloaded successfully', 'success');
        }

        function copyToClipboard() {
            const content = document.getElementById('values-editor').textContent;
            navigator.clipboard.writeText(content).then(() => {
                showNotification('Values.md content copied to clipboard', 'success');
            }).catch(() => {
                showNotification('Failed to copy to clipboard', 'error');
            });
        }

        function validateWithAI() {
            showNotification('AI validation feature coming soon', 'info');
        }

        function exportFullAnalysis() {
            const analysis = {
                session: gameState.sessionId,
                responses: gameState.responses,
                metrics: gameState.getAnalysisMetrics(),
                topMotifs: gameState.getTopMotifs(),
                qualityMetrics: dataManager.qualityMetrics,
                timestamp: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(analysis, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `analysis-${gameState.sessionId}.json`;
            link.click();
            
            URL.revokeObjectURL(url);
            showNotification('Full analysis exported', 'success');
        }

        function restartAssessment() {
            if (confirm('Start a new assessment? Your current progress will be lost.')) {
                gameState.reset();
                dataManager.usedDilemmas.clear();
                document.getElementById('results-panel').classList.remove('active', 'expanded');
                updateProgressRing();
                loadNextDilemma();
                showNotification('Assessment restarted', 'success');
            }
        }

        // === KEYBOARD CONTROLS ===
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            const key = e.key.toLowerCase();
            const keyMap = { 'a': 0, 's': 1, 'd': 2, 'f': 3 };
            
            if (keyMap.hasOwnProperty(key)) {
                e.preventDefault();
                selectChoice(keyMap[key]);
            }
        });

        // === INITIALIZATION ===
        document.addEventListener('DOMContentLoaded', () => {
            initialize().catch(error => {
                console.error('Application initialization failed:', error);
                hideLoading();
                showNotification('Application failed to initialize properly. Using fallback mode.', 'error');
                showAssessment();
                loadNextDilemma();
            });
        });
    </script>
</body>
</html>
